
当今的很多应用都是属于数据密集型，而非计算密集型应用。对于这些应用，CPU的处理能力并不是第一限制因素，关键在于数据量、数据复杂度与数据多样性。

包括数据库、高速缓存、索引、流式处理、批处理等都属于数据密集型应用。

## 数据库
关系型数据库的最大问题在于，在面向对象语言中，如果数据存的关系表中，则对象和表需要一个笨拙的转换层，即阻抗失谐。
当然除了关系模型，还有文档模型、网状模型、图状模型··· 

内存数据库性能一般比硬盘数据库更快，并且因为使用内存，所以可以提供基于磁盘索引难以提供的某些数据结构，代表就是Redis中的各种数据结构。

### 数据的存储与检索

存储引擎决定了数据在数据库中的存储，即决定其数据结构。

首先，争对事务型工作负载（OLTP）与争对分析型工作负载（OLAP）的存储引擎优化其实存在很大区别。

而在OLTP存储引擎中，常见的又有两种，即日志结构的存储引擎与面向页的存储引擎，如B-Tree。

最简单的是一个shell脚本，每次set时候顺序写入文件最后，get使用grep命令，输出vaule值。

#### 哈希索引
首先索引是基于原始数据结构产生的额外数据结构，不影响数据内容，只会影响查询性能。所以写入时势必会有些开销。

首先大多数编程语言都内置了hashmap，这些数据都保存在内存。假设数据存储全部采用追加式文件。那么最简单的索引策略就是：
保存内存中hashmap，把每个键都一一映射到数据文件中特定的字节偏移量，这样就可以找到每个值的位置。老实说这个方案看起来很简单，但实际很有效。

优点：
1.存储空间。value存储在文件中，于是vaule数据量可以超过内存的大小，并且只要一次磁盘寻址，就可以把value从磁盘加载到内存。如果文件已经在缓存，则直接更可以读取。
2.更新和删除速度快。删除直接追加一个墓碑标记，更新则也是写入，只是更新vaule的字段。由于都是顺序写，所以比找位置再更新的速度快。
3.崩溃恢复。如果数据库重新启动，则内存中hashmap会丢失。但原则上，可以通过从头到尾读取文件，恢复hashmap。
4.并发控制。由于写入以严格的先后顺序追加到日志，通常使用只有一个写线程，多个读线程。
5.碎片化处理。由于更新直接写入，所以数据会增多，可以使用另一个线程清除脏数据，压缩空间。可以保证碎片化处理高效。

缺点：
1.hashmap必须全部放入内存，如果有大量的键，其实就不那么好找了。
2.区间查询效率不高。对区间内的值只能追个扫描。


#### SSTables
在上一段中，每个日志结构的存储都是一个key-value对，按照写入顺序排序，但是最大的问题是不支持区间查询。
为了实现这个目的，其实需要把日志中的key-vaule对的顺序按键排序。这种格式称为SSTables，排序字符串表。它要求每个键在合并的段文件中只能出现一次，并按顺序排序。

为了实现这个目的，最大的问题其实是排序，有一些基于硬盘的排序，比如后面的B Tree。但是内存中排序其实方法更多，比如红黑树或AVL树。
使用这些数据结构，可以按照任意顺序插入键并以排序后的顺序读取他们。实际使用SSTables、内存表的有LevelDB、RocksDB、Cassandra、HBase、ES的存储引擎Lucene等。


#### LSM Tree
LSM Tree（Log Structures Merge Tree） 日志结构的合并树。建立在日志结构的文件系统上，基于合并和压缩排序的文件原理。

优点：
1.合并段更加高效。即使数据远大于内存，仍可以正常工作。
2.在文件中查找特定的键，不需要在内存中保存所有键的索引。只需要保留某些稀疏的键就可以按照顺序来查了，
3.由于数据按序排序，可以有效执行区间查询。
4.磁盘顺序写入，LSM Tree可以有很高的写入吞吐量。

缺点：
1.当键不存在时，需要先检查内存表，将段一直回溯到最旧的段文件（可能必须从磁盘中多次读取）。一般需要使用额外的布隆过滤器判断不存在。

#### B Tree
B Tree，几乎已经成为所有关系数据库的标准索引实现，且很多非关系型数据库也经常使用。B Tree和LSM Tree唯一相同的只有kv按序存储。
实际最关键的是，数据库启动时把数据库分解称固定大小的块或页。每个页都可以让另一页引用，这个指向是真正指向硬盘地址，而非内存；

使用这种方式其实引入了很多问题，比如：
更新值，需要先找到该键，更新页的值，并将页写回磁盘。
新增值，首先要找到该键的页，并将其添加到页，如果页没有可用空间，则会触发到页分裂。
并发更新，LSM Tree 每次直接追加更新就好，B Tree则在多个线程同时更新一个值是就会有并发问题了，一般需要锁。
崩溃恢复，为了让数据库能崩溃恢复，一般需要预写日志（write ahead log WAL），也称为重做日志，redo log。

但是通常认为LSM Tree写入更快，B Tree读取更快。对于事务管理，B Tree每个键都恰好对于索引中某个位置，而LSM Tree对应多个，所以B Tree对事务的支持更好。

#### Kafka日志索引
Kafka的存储结构，每个partition对应的是一个Log文件，并且对应了两个索引文件来提高查询的效率。
偏移量索引文件用来建立消息偏移量（offset）到物理地址的映射关系。
时间戳索引文件用来建立指定时间戳（timestamp）到物理地址的映射关系。

Kafka中的索引文件以稀疏索引的方式构造消息的索引，它并不保证每个消息索引文件中都有对应的索引项。每写入一定量消息，默认4KB，索引文件直接更新对应文件大小。
索引文件会通过MappedByteBuffer将索引文件映射到内存中。由于所以存储是顺序，查询指定偏移量时可以使用二分查找来快速定位偏移量。

#### ES索引
对于MYSQL这种B树类索引，一个很重要的点就是树的高度要低，这也才能进快找到页、找到数据。之所以使用B+树，就是B+树仅叶节点存数据，根和枝节点不存数据。这样每个页就能存更多的数据，从而分支更多，高度更短。
但是当索引值很大时，比如把一个Text值拿来当索引，则B+树性能会急剧下降，因为每页存储的数据减少，树的高度上升。

而全文索引正是上面说的，会对大文本进行索引的场景。并且B+树遵循最左前缀匹配，而全文索引一般不满足该场景，所以肯定是无法使用B+树。

全文索引首先会对文档进行切词处理，再将切好的词与文本进行关联，并进行索引。

正排索引，使用文档 id 作为索引关键字，同时记录了这篇文档中有哪些词（经过分词器处理），每个词出现的次数已经每个词在文档中的位置。

倒排索引，使用的是词来作为索引关键字，并同时记录了哪些文档中有这个词，以及该词在文档的什么位置等很多信息。

最后ES存储使用FST来进行索引存储。

#### B+ Tree
InnoDb底层采用B+树存储，是针对读取场景性能更好的存储引擎。当B+树需要读取数据时，就会在磁盘上寻址，如果找到了就返回客户端。
同样B+树写入时也需要在磁道上寻址，寻址成功后原地更新。整体时间复杂度是O(logn)。并且B+树是可变数据结构，B+树的页在每次写入操作达到一个阈值后，会触发分裂操作。

而对于LSM Tree，仅追加存储结果，每次写操作都能切仅能在内存中进行写操作，因此写操作不必在磁道上寻址。而读操作则因为底层SST中存储多个版本的数据，需要进行协调。
此外，通过在磁盘中进行追加写操作，避免了随机写。SSTable做为不可变数据结构，存储空间利用率高。每次写入写内存，到达一定程度后进行dump操作。dump成SSTable。