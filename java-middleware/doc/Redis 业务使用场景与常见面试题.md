
https://tech.meituan.com/2016/12/02/performance-tunning.html
## 1.项目中怎么使用Redis的

1. 缓存，存数据库的配置。（路由配置、权限配置）
2. NoSQL，存接口调用次数。
3. NoSQL，存JWT签发的Token。


## 2.Redis能用来存什么

Redis作为一种键值对数据库，适合于对单条数据的更新，删除，查询。比如存接口调用次数(每次调用+1)、礼物总数(每次调用-1)、Token(定时过期)、排行榜(ZADD)
而当涉及范围查询时就必须全表查询或者前缀查询，这部分还是得交给关系型数据库。当然解决办法也是有的，就是存的时候就按照需要的格式去存，把关系型数据库的表结构在Redis中进行改造。  

还有一种常用场景是当关系型数据库的缓存，将某些耗时较久且结果变化不频繁的SQL的运行结果放到缓存中，后面请求直接访问缓存，加快请求，防止数据库崩。
但是这种场景在后面数据库数据频繁变动的场景下就不合适了。并且需要考虑数据库和Redis的同步机制(已经被抽象成经典设计模式 参见https://coolshell.cn/articles/17416.html):
这里只介绍最经典的一种，Cache Aside Pattern。
> 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。 if(RedisUtil.hasKey){return };list = SQL;RedisUtil.set();
> 更新的时候，先更新数据库，然后再删除缓存。           if(UpdateSQL) {RefeshRedis；}
> 刷新缓存时，直接delete缓存，然后用读命令重新刷进去。 RedisUtil.del();findAll();

当数据库、Redis、Kafka都存消息，并且需要同步的时候，可以使用单独的中间件去维护同步，而非业务层去解决。比如LinkedIn的databus、阿里的canal。类似读写分离的架构。(刚修改就读的从主库读，其他的从缓存读)    
参考文档：  https://www.cnblogs.com/crazymakercircle/p/13900198.html


另外一种常用场景是拿Redis当分布式锁，在多个后端同时对数据库进行操作时，只有拿到分布式锁的人才能进行操作。于是就需要引入分布式锁。Redis实现的方案：
多个后端都用setnx来争抢锁，抢到之后再用expire给锁加一个过期时间，防止自己crash了锁永远无法释放。setnx和expire要合成一条指令。

理论上还有一种场景是拿Redis当异步消息队列来用，使用Redis的Pub/Sub模式。比如使用Redis的RedisMessageListenerContainer类，监听某个键值对，并触发对应事件。
参考文档：  https://www.cnblogs.com/linjiqin/p/6277537.html

Web场景中，在这些场景下可以充分的利用Redis的特性，提高效率。
* 在主页中显示最新的项目列表：Redis使用的是常驻内存的缓存，速度非常快。LPUSH用来插入一个内容ID，作为关键字存储在列表头部。LTRIM用来限制列表中的项目数最多为5000。如果用户需要的检索的数据量超越这个缓存容量，这时才需要把请求发送到数据库。
* 删除和过滤：如果一篇文章被删除，可以使用LREM从缓存中彻底清除掉。
* 排行榜及相关问题：排行榜（leader board）按照得分进行排序。ZADD命令可以直接实现这个功能，而ZREVRANGE命令可以用来按照得分来获取前100名的用户，ZRANK可以用来获取用户排名，非常直接而且操作容易。
* 按照用户投票和时间排序：排行榜，得分会随着时间变化。LPUSH和LTRIM命令结合运用，把文章添加到一个列表中。一项后台任务用来获取列表，并重新计算列表的排序，ZADD命令用来按照新的顺序填充生成列表。列表可以实现非常快速的检索，即使是负载很重的站点。
* 过期项目处理：使用Unix时间作为关键字，用来保持列表能够按时间排序。对current_time和time_to_live进行检索，完成查找过期项目的艰巨任务。另一项后台任务使用ZRANGE…WITHSCORES进行查询，删除过期的条目。
* 计数：进行各种数据统计的用途是非常广泛的，比如想知道什么时候封锁一个IP地址。INCRBY命令让这些变得很容易，通过原子递增保持计数；GETSET用来重置计数器；过期属性用来确认一个关键字什么时候应该删除。
* 特定时间内的特定项目：这是特定访问者的问题，可以通过给每次页面浏览使用SADD命令来解决。SADD不会将已经存在的成员添加到一个集合。
* Pub/Sub：在更新中保持用户对数据的映射是系统中的一个普遍任务。Redis的pub/sub功能使用了SUBSCRIBE、UNSUBSCRIBE和PUBLISH命令，让这个变得更加容易。
* 队列：在当前的编程中队列随处可见。除了push和pop类型的命令之外，Redis还有阻塞队列的命令，能够让一个程序在执行时被另一个程序添加到队列。


参考文档：  
https://zhuanlan.zhihu.com/p/45724478
https://www.infoq.cn/article/8t5l16piikwp0imifhlk  



## 3.缓存穿透、击穿、雪崩
如果流量都是按数据库支持的范围内进来的，那数据库自然不会有影响，查数据库查到了再更新缓存即可。  
但实际中意外的流量总会出现，可能是真正用户来了，也可能是黑客来了。  

* 缓存穿透  
Redis没有数据，Mysql也没有该数据。但是用户不断请求，就会不断去查数据库。系统压力就会增大。
> 解决方案:如果Redis、Mysql都没查到，则设置一个默认返回的null值key存到Redis，后面业务逻辑看到null值直接返回无。 
> 当恶意流量穿透攻击来时，会构造千万级Redis、数据库都没有的数据，这样MySQL就要查千万级别，直接挂。比如判某个id是否会员，如果Redis查不到则从数据库取，构建id为负数，每次都去数据库查。
> 这时候可以把一些信息放到布隆过滤器中，比如IP黑名单，用户会员数据，将所有查询条件放到布隆过滤器，先进行一次bitmap的过滤。

* 缓存击穿
Redis没有数据，Mysql有数据。并且该key为热点key，突然同时很多用户请求这个不在Redis的热点key，数据库压力增大，且可能导致重复更新Redis。
> 解决方案:需要一套合理的Redis、Mysql同步机制。比如部分热点key是否可设置为永不失效；如果Redis key一定会失效，同样的请求是否可以基于分布式锁让少量请求访问数据库了，并捞到缓存；如果数据更新频繁，考虑其他中间件同步缓存。

* 缓存雪崩
Redis没有数据，Mysql无数据。用户不断请求，数据库压力增大，同缓存击穿的区别是，雪崩是多个数据同时失效。  
> 解决方案:本质和上面一样，需要一套合理的同步机制。实际操作可以使用不同的过期时间，定时任务更新key等方法。 



## Redis使用的意外情况
虽然Redis性能很好，但是由于是单CPU操作，所以只要有一个慢查询或者阻塞的查询就会导致性能急速下降。所以需要开发尽量避免一些可能会引起阻塞的操作。

> 由于Redis语句引起Redis阻塞的场景：

1.keys * 语句。大数据在操作时会阻塞Redis。可以使用dbsize命令直接获取。或者使用scan渐进式获取值，

2.del命令删除较大的键时，也会存在阻塞Redis的可能。

3.对大表的vaule值进行操作，比如对200w个元素，进行hgetall。

> 由于客户端配置导致的问题

1.无法从连接池获取到连接。比如客户端没有归还连接，客户端高并发-就是有这么多连接，存在慢查询导致连接归还速度较慢。

2.客户端读写超时。读写超时时间设计较短、Redis自身阻塞、客户端服务端连接异常。

3.客户端调用时，出现客户端数据流正常。原因可能有输出缓冲区慢，不正常的并发读写。

4.Redis读取数据报no such class
问题：报错 读取redis数据报no such class
原因：之前在Redis中保存实体类的对象的包路径发生了变化，原来是xxA的类，变成了test.xxA的类。这时候就会导致序列化异常。、
因为从Redis中拿到的数据相当于是脏数据，再执行序列化的时候就失败了。类似的用MySQL存也是会出现这个情况的。
解决办法： 删除Redis原来的数据，重新添加就可以了，或者包路径变回去。

> 由于应用设计及配置导致的问题

1.存数据的设计有问题导致Redis内存满了 实际一般我们的基本款就4G内存。
原因：每条存5w条数据，保存10天，每个数据15k，一共约1.5G. 

2.存取数据大于client端默认buffer大小 1M。

3.使用大量短链接导致的连接创建、销毁导致的CPU升高
为了解决大量短链频繁创建socket的问题，一般是引入pipline，相当于减少建链时间。当然pipline也可能会出现新的问题。
并且Redis的连接数大于maxClient（默认10000）时会报拒绝连接。

4.pipline消费端能力不足导致的CPU升高
Pipeline的好处是可以将多次IO的往返时间缩短到一次，需要注意这需要pipline执行的指令之间没有因果性。

5.大量连接时频繁使用info、monitor
info可以获取当前的存储、内存、连接状态。生产一般会禁用monitor。

6.开启了持久化功能，持久化可能导致阻塞。fork阻塞、AOF刷盘阻塞、HugePage写操作阻塞。

7.由于内存满了使用swap导致的性能下降，可以使用cat /proc/Pid/smaps | grep Swap

## Redis慢查询
默认开启慢查询，超过10ms的命令会被记录，默认大小只有128条，多了会更新。
由于Redis采用单线程响应命令，如果是1ms，则QPS只有1000.如果是10ms，则QPS则仅有100。

## Redis OOM
使用Redis命令可以使用查看内存分配：info memory。

Redis内存回收在两个情况下触发：删除到达过期时间的键对象，内存使用到达maxmemory上限时触发内存溢出控制策略。内置6种策略。
1.noeviction。默认策略，不会删除任何数据，拒绝写入操作，并返回OOM错误。
2.volatile-lru。根据LRU算法删除设置了超时时间的键，直到腾出足够空间，如果没有可用的键，返回noeviction。
3.allkeys-lru。根据LRU算法删除所有键，直到腾出足够空间。
4.allkeys-Random。随机删除所有键，直到腾出足够空间。
5.volatile-Random。随机删除设置了超时时间的键。
6.volatile-ttl。根据超时时间先后删除键。

## 常见面试题
Q:redis性能为什么高?
1.纯内存访问，响应时间在几十纳秒。
2.非阻塞IO，使用epoll实现多路复用。
3.单线程避免线程切换和竞态问题。
4.数据结构使用内置数据结构来进行优化，比如使用共享对象池优化小整数数据、使用ziplist压缩编码hash、list等结构、C不支持内存回收，Redis在自己的对象系统种构建了一个引用计数计数实现的内存回收ji'zhi 。


Q:单线程的redis如何利用多核cpu机器？

Q:redis的缓存淘汰策略？

Q:redis如何持久化数据？

Q:redis有哪几种数据结构？

Q:redis的集合有没有限制，限制是多少?

Q:Redis 哈希表进行 rehash 的触发时机是什么？

Q:redis集群有哪几种形式？

Q:哨兵模式，选举过程，会有脑裂问题么？

Q:有海量key和value都比较小的数据，在redis中如何存储才更省内存？

Q:如何保证redis和DB中的数据一致性？

Q:如何解决缓存穿透和缓存雪崩？
穿透指不存在的数据，缓存和MYSQL都不存在，所以查询一定会走到MYSQL。穿透优化，可以使用缓存空对象，或者布隆过滤器拦截来解决。
雪崩指大量key失效，请求打到数据库，这时候已经不能靠应用层逻辑，把查到的key再插回缓存，因此那一次的大批量访问数据库就能让你GG。
雪崩的解决方案有：保证缓存层的服务高可用，依赖隔离组件为后端限流并降级。


Q:如何用redis实现分布式锁？





参考文档：  
https://www.infoq.cn/article/yquus2qnrybilgrquliv
http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%AF%B4%E9%80%8F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/17%20%20%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%20Redis%20%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9%EF%BC%9F.md