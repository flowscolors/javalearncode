
数据库中的锁，也分很多类型。并且不同存储引擎的锁也不同，只是一般我们都是基于Innodb展开讨论。



## 2.MYSQL InnoDB 中的各种锁
* 乐观锁和悲观锁
确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，乐观锁和悲观锁是并发控制主要采用的技术手段。

悲观锁 - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务（COMMIT）。实现方式：使用数据库中的锁机制。

乐观锁 - 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定。实现方式：使用 version 版本或者时间戳

* 行级锁和表级锁
从数据库的锁粒度来看，MySQL 中提供了两种封锁粒度：行级锁和表级锁。

表级锁（table lock） - 锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。
行级锁（row lock） - 仅对指定的行记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。

* 读写锁/共享锁与排他锁 
独享锁（Exclusive），简写为 X 锁，又称写锁。使用方式：SELECT ... FOR UPDATE;
共享锁（Shared），简写为 S 锁，又称读锁。使用方式：SELECT ... LOCK IN SHARE MODE;
写锁和读锁的关系，简言之：独享锁存在，其他事务就不能做任何操作。

当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就会出现死锁，
在数据库中有两种基本的锁类型：排它锁(Exclusive Locks，即X锁)和共享锁(Share Locks，即S锁)。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两 种基本的锁类型来对数据库的事务进行并发控制。

InnoDB 下的行锁、间隙锁、next-key 锁统统属于独享锁。

*  意向锁

意向锁的作用是：当存在表级锁和行级锁的情况下，必须先申请意向锁（表级锁，但不是真的加锁），再获取行级锁。使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

意向锁是 InnoDB 自动加的，不需要用户干预。

* MVCC
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

MVCC 的思想是：

保存数据在某个时间点的快照。写操作（DELETE、INSERT、UPDATE）更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

* Next-key 锁
Next-Key 锁是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻读问题，Next-Key 锁就是为了解决幻读问题。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key 锁 可以解决幻读问题。

另外，根据针对 SQL 语句检索条件的不同，加锁又有以下三种情形需要我们掌握。

Record Lock - 行锁对索引项加锁，若没有索引则使用表锁。
Gap Lock - 对索引项之间的间隙加锁。锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
Next-key lock -它是 Record Lock 和 Gap Lock 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间。
索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 UPDATE、DELETE 操作时，MySQL 不仅锁定 WHERE 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 next-key lock。

当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。


锁的实验：  
https://weikeqin.com/2019/09/05/mysql-lock-table-solution/



## 锁检查
> select * from performance_schema.events_statements_current WHERE THREAD_ID = 105;

使用上述命令可以看到SQL命令与TIMER_START、TIMER_END、TIMER_WAIT 、LOCK_TIME四个字段，单位都是ps（皮秒，亿万分之一秒）



## 死锁案例




参考文档：  
https://www.cnblogs.com/sessionbest/articles/8689082.html
https://cloud.tencent.com/document/product/1130/42596
https://blog.csdn.net/weixin_39845406/article/details/113144655