
当把Redis作为NOSQL使用时，需要使用Redis对缓存的持久化支持。以此来保证缓存的可用性。

## 持久化方法
Redis一共支持四种持久化方式，主要使用的两种：

1. 定时快照方式(snapshot) RDB方式：该持久化方式实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页（page）为单位来进行copy-on-write保证父子进程之间不会互相影响。
   优点:适合全量备份，恢复速度比AOF快。是默认持久化方法。
   缺点:快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。  

2. 基于语句追加文件的方式(aof)：aof方式实际类似MySQl的基于语句的binlog方式，即每条会使Redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是Redis的持久化数据。
   优点:实时性高，可以做到只丢1~2的数据。
   缺点: 1.追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢,读取的所有命令都要在内存中执行一遍。 2.由于每条命令都要写log，所以使用aof的方式，Redis的读写性能也会有所下降。  

3. 虚拟内存技术。使用虚拟内存技术把那些不经常访问的数据交换到磁盘上。通过虚存将其余不常用的Keys和Values换出到磁盘上，而一旦这些被换出的Keys或Values需要被读取时，Redis则将其再次读回到主内存中。从Redis Version 2.4开始就被官方明确表示不再建议使用。

4. diskstore方式。diskstore方式是作者放弃了虚拟内存方式后选择的一种新的实现方式，也就是传统的B-tree的方式。最后实现的方法就是将每个value作为一个独立文件保存，文件名是key的hash值。

Redis 4.0 提供了RDB-AOF混合模式的持久化格式。 Redis 7.0 提供了多线程AOF机制。

### 过期策略
redis 过期策略是：定期删除+惰性删除。

定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。
惰性删除，指的是 redis在获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。

### 内存淘汰策略
当就是内存使用满了，并且存的值都未过期，这时候再有新的key进来，就会触发内存淘汰。
redis 内存淘汰机制有以下几个：
noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

## 高可用机制


### 哨兵模式


### 集群模式
集群模式的高可用版本，每个集群节点也是主从关系，该主从基于哨兵实现。  
Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个hash槽，每个节点上可以存储一个或多个hash槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。  

整体设计可总结为：
* 数据hash分布在不同的Redis节点实例上；
* M/S的切换采用Sentinel；
* 写：只会写master Instance，从sentinel获取当前的master Instance；
* 读：从Redis Node中基于权重选取一个Redis Instance读取，失败/超时则轮询其他Instance；Redis本身就很好的支持读写分离，在单进程的I/O场景下，可以有效的避免主库的阻塞风险；
