
当今的很多应用都是属于数据密集型，而非计算密集型应用。对于这些应用，CPU的处理能力并不是第一限制因素，关键在于数据量、数据复杂度与数据多样性。

包括数据库、高速缓存、索引、流式处理、批处理等都属于数据密集型应用。

## 数据库
关系型数据库的最大问题在于，在面向对象语言中，如果数据存的关系表中，则对象和表需要一个笨拙的转换层，即阻抗失谐。
当然除了关系模型，还有文档模型、网状模型、图状模型··· 

内存数据库性能一般比硬盘数据库更快，并且因为使用内存，所以可以提供基于磁盘索引难以提供的某些数据结构，代表就是Redis中的各种数据结构。

### 数据的存储与检索

存储引擎决定了数据在数据库中的存储，即决定其数据结构。

首先，争对事务型工作负载（OLTP）与争对分析型工作负载（OLAP）的存储引擎优化其实存在很大区别。

而在OLTP存储引擎中，常见的又有两种，即日志结构的存储引擎与面向页的存储引擎，如B-Tree。

最简单的是一个shell脚本，每次set时候顺序写入文件最后，get使用grep命令，输出vaule值。

#### 哈希索引
首先索引是基于原始数据结构产生的额外数据结构，不影响数据内容，只会影响查询性能。所以写入时势必会有些开销。

首先大多数编程语言都内置了hashmap，这些数据都保存在内存。假设数据存储全部采用追加式文件。那么最简单的索引策略就是：
保存内存中hashmap，把每个键都一一映射到数据文件中特定的字节偏移量，这样就可以找到每个值的位置。老实说这个方案看起来很简单，但实际很有效。

优点：
1.存储空间。value存储在文件中，于是vaule数据量可以超过内存的大小，并且只要一次磁盘寻址，就可以把value从磁盘加载到内存。如果文件已经在缓存，则直接更可以读取。
2.更新和删除速度快。删除直接追加一个墓碑标记，更新则也是写入，只是更新vaule的字段。由于都是顺序写，所以比找位置再更新的速度快。
3.崩溃恢复。如果数据库重新启动，则内存中hashmap会丢失。但原则上，可以通过从头到尾读取文件，恢复hashmap。
4.并发控制。由于写入以严格的先后顺序追加到日志，通常使用只有一个写线程，多个读线程。
5.碎片化处理。由于更新直接写入，所以数据会增多，可以使用另一个线程清除脏数据，压缩空间。可以保证碎片化处理高效。

缺点：
1.hashmap必须全部放入内存，如果有大量的键，其实就不那么好找了。
2.区间查询效率不高。对区间内的值只能追个扫描。


#### SSTables
在上一段中，每个日志结构的存储都是一个key-value对，按照写入顺序排序，但是最大的问题是不支持区间查询。
为了实现这个目的，其实需要把日志中的key-vaule对的顺序按键排序。这种格式称为SSTables，排序字符串表。它要求每个键在合并的段文件中只能出现一次，并按顺序排序。

为了实现这个目的，最大的问题其实是排序，有一些基于硬盘的排序，比如后面的B Tree。但是内存中排序其实方法更多，比如红黑树或AVL树。
使用这些数据结构，可以按照任意顺序插入键并以排序后的顺序读取他们。实际使用SSTables、内存表的有LevelDB、RocksDB、Cassandra、HBase、ES的存储引擎Lucene等。


#### LSM Tree
LSM Tree（Log Structures Merge Tree） 日志结构的合并树。建立在日志结构的文件系统上，基于合并和压缩排序的文件原理。

优点：
1.合并段更加高效。即使数据远大于内存，仍可以正常工作。
2.在文件中查找特定的键，不需要在内存中保存所有键的索引。只需要保留某些稀疏的键就可以按照顺序来查了，
3.由于数据按序排序，可以有效执行区间查询。
4.磁盘顺序写入，LSM Tree可以有很高的写入吞吐量。

缺点：
1.当键不存在时，需要先检查内存表，将段一直回溯到最旧的段文件（可能必须从磁盘中多次读取）。一般需要使用额外的布隆过滤器判断不存在。

#### B Tree
B Tree，几乎已经成为所有关系数据库的标准索引实现，且很多非关系型数据库也经常使用。B Tree和LSM Tree唯一相同的只有kv按序存储。
实际最关键的是，数据库启动时把数据库分解称固定大小的块或页。每个页都可以让另一页引用，这个指向是真正指向硬盘地址，而非内存；

使用这种方式其实引入了很多问题，比如：
更新值，需要先找到该键，更新页的值，并将页写回磁盘。
新增值，首先要找到该键的页，并将其添加到页，如果页没有可用空间，则会触发到页分裂。
并发更新，LSM Tree 每次直接追加更新就好，B Tree则在多个线程同时更新一个值是就会有并发问题了，一般需要锁。
崩溃恢复，为了让数据库能崩溃恢复，一般需要预写日志（write ahead log WAL），也称为重做日志，redo log。

但是通常认为LSM Tree写入更快，B Tree读取更快。对于事务管理，B Tree每个键都恰好对于索引中某个位置，而LSM Tree对应多个，所以B Tree对事务的支持更好。

#### B+ Tree