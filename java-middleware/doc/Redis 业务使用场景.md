
https://tech.meituan.com/2016/12/02/performance-tunning.html
## 1.项目中怎么使用Redis的

1. 缓存，存数据库的配置。（路由配置、权限配置）
2. NoSQL，存接口调用次数。
3. NoSQL，存JWT签发的Token。


## 2.Redis能用来存什么

Redis作为一种键值对数据库，适合于对单条数据的更新，删除，查询。比如存接口调用次数(每次调用+1)、礼物总数(每次调用-1)、Token(定时过期)、排行榜(ZADD)
而当涉及范围查询时就必须全表查询或者前缀查询，这部分还是得交给关系型数据库。当然解决办法也是有的，就是存的时候就按照需要的格式去存，把关系型数据库的表结构在Redis中进行改造。  

还有一种常用场景是当关系型数据库的缓存，将某些耗时较久且结果变化不频繁的SQL的运行结果放到缓存中，后面请求直接访问缓存，加快请求，防止数据库崩。
但是这种场景在后面数据库数据频繁变动的场景下就不合适了。并且需要考虑数据库和Redis的同步机制(已经被抽象成经典设计模式 参见https://coolshell.cn/articles/17416.html):
这里只介绍最经典的一种，Cache Aside Pattern。
> 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。 if(RedisUtil.hasKey){return };list = SQL;RedisUtil.set();
> 更新的时候，先更新数据库，然后再删除缓存。           if(UpdateSQL) {RefeshRedis；}
> 刷新缓存时，直接delete缓存，然后用读命令重新刷进去。 RedisUtil.del();findAll();

当数据库、Redis、Kafka都存消息，并且需要同步的时候，可以使用单独的中间件去维护同步，而非业务层去解决。比如LinkedIn的databus、阿里的canal。类似读写分离的架构。(刚修改就读的从主库读，其他的从缓存读)    
参考文档：  https://www.cnblogs.com/crazymakercircle/p/13900198.html


另外一种常用场景是拿Redis当分布式锁，在多个后端同时对数据库进行操作时，只有拿到分布式锁的人才能进行操作。于是就需要引入分布式锁。Redis实现的方案：
多个后端都用setnx来争抢锁，抢到之后再用expire给锁加一个过期时间，防止自己crash了锁永远无法释放。setnx和expire要合成一条指令。

理论上还有一种场景是拿Redis当异步消息队列来用，使用Redis的Pub/Sub模式。比如使用Redis的RedisMessageListenerContainer类，监听某个键值对，并触发对应事件。
参考文档：  https://www.cnblogs.com/linjiqin/p/6277537.html

Web场景中，在这些场景下可以充分的利用Redis的特性，提高效率。
* 在主页中显示最新的项目列表：Redis使用的是常驻内存的缓存，速度非常快。LPUSH用来插入一个内容ID，作为关键字存储在列表头部。LTRIM用来限制列表中的项目数最多为5000。如果用户需要的检索的数据量超越这个缓存容量，这时才需要把请求发送到数据库。
* 删除和过滤：如果一篇文章被删除，可以使用LREM从缓存中彻底清除掉。
* 排行榜及相关问题：排行榜（leader board）按照得分进行排序。ZADD命令可以直接实现这个功能，而ZREVRANGE命令可以用来按照得分来获取前100名的用户，ZRANK可以用来获取用户排名，非常直接而且操作容易。
* 按照用户投票和时间排序：排行榜，得分会随着时间变化。LPUSH和LTRIM命令结合运用，把文章添加到一个列表中。一项后台任务用来获取列表，并重新计算列表的排序，ZADD命令用来按照新的顺序填充生成列表。列表可以实现非常快速的检索，即使是负载很重的站点。
* 过期项目处理：使用Unix时间作为关键字，用来保持列表能够按时间排序。对current_time和time_to_live进行检索，完成查找过期项目的艰巨任务。另一项后台任务使用ZRANGE…WITHSCORES进行查询，删除过期的条目。
* 计数：进行各种数据统计的用途是非常广泛的，比如想知道什么时候封锁一个IP地址。INCRBY命令让这些变得很容易，通过原子递增保持计数；GETSET用来重置计数器；过期属性用来确认一个关键字什么时候应该删除。
* 特定时间内的特定项目：这是特定访问者的问题，可以通过给每次页面浏览使用SADD命令来解决。SADD不会将已经存在的成员添加到一个集合。
* Pub/Sub：在更新中保持用户对数据的映射是系统中的一个普遍任务。Redis的pub/sub功能使用了SUBSCRIBE、UNSUBSCRIBE和PUBLISH命令，让这个变得更加容易。
* 队列：在当前的编程中队列随处可见。除了push和pop类型的命令之外，Redis还有阻塞队列的命令，能够让一个程序在执行时被另一个程序添加到队列。


参考文档：  
https://zhuanlan.zhihu.com/p/45724478
https://www.infoq.cn/article/8t5l16piikwp0imifhlk  



## 3.缓存穿透、击穿、雪崩
如果流量都是按数据库支持的范围内进来的，那数据库自然不会有影响，查数据库查到了再更新缓存即可。  
但实际中意外的流量总会出现，可能是真正用户来了，也可能是黑客来了。  

* 缓存穿透  
Redis没有数据，Mysql也没有该数据。但是用户不断请求，就会不断去查数据库。系统压力就会增大。
> 解决方案:如果Redis、Mysql都没查到，则设置一个默认返回的null值key存到Redis，后面业务逻辑看到null值直接返回无。 
> 当恶意流量穿透攻击来时，会构造千万级Redis、数据库都没有的数据，这样MySQL就要查千万级别，直接挂。比如判某个id是否会员，如果Redis查不到则从数据库取，构建id为负数，每次都去数据库查。
> 这时候可以把一些信息放到布隆过滤器中，比如IP黑名单，用户会员数据，将所有查询条件放到布隆过滤器，先进行一次bitmap的过滤。

* 缓存击穿
Redis没有数据，Mysql有数据。并且该key为热点key，突然同时很多用户请求这个不在Redis的热点key，数据库压力增大，且可能导致重复更新Redis。
> 解决方案:需要一套合理的Redis、Mysql同步机制。比如部分热点key是否可设置为永不失效；如果Redis key一定会失效，同样的请求是否可以基于分布式锁让少量请求访问数据库了，并捞到缓存；如果数据更新频繁，考虑其他中间件同步缓存。

* 缓存雪崩
Redis没有数据，Mysql无数据。用户不断请求，数据库压力增大，同缓存击穿的区别是，雪崩是多个数据同时失效。  
> 解决方案:本质和上面一样，需要一套合理的同步机制。实际操作可以使用不同的过期时间，定时任务更新key等方法。 



## Redis使用的意外情况

* Redis内存满了 实际一般我们的基本款就4G内存。
原因：每条存5w条数据，保存10天，每个数据15k，一共约1.5G. 


* 大量短链接导致的连接创建、销毁导致的CPU升高


* 大量连接时频繁使用info
info可以获取当前的存储、内存、连接状态。


* pipline消费端能力不足导致的CPU升高
Pipeline的好处是可以将多次IO的往返时间缩短到一次，需要注意这需要pipline执行的指令之间没有因果性。


* Redis读取数据报no such class
问题：报错 读取redis数据报no such class
原因：之前在Redis中保存实体类的对象的包路径发生了变化，原来是xxA的类，变成了test.xxA的类。这时候就会导致序列化异常。
解决办法： 删除Redis原来的数据，重新添加就可以了，或者包路径变回去。


参考文档：  
https://www.infoq.cn/article/yquus2qnrybilgrquliv
http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%AF%B4%E9%80%8F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/17%20%20%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%20Redis%20%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9%EF%BC%9F.md