

事务将应用程序的多个读、写操作绑定在一起成为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交），要么失败（中止或回。滚）

有了事务，应用程序可以不用考虑某些内部潜在错误或复制的并发性问题。当然并非所有应用程序都需要事务，有时可以弱化事务或完全放弃事务来获取更高性能。

事务简单来说：一个 Session 中所进行所有的操作，要么同时成功，要么同时失败。具体来说，事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。


### ACID
事务的四大特性 （ACID）
       1、原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
       2、一致性（Consistency）事务前后数据的完整性必须保持一致。
       3、隔离性（Isolation）多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间的数据要相互隔离。
       4、持久性（Durability）一个事务一旦被提交，它对数据库中的数据改变就是永久性的。

参考文档：  
https://dunwu.github.io/db-tutorial/sql/common/sql-interview.html#%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98

### 事务的隔离级别
 多个线程开启各自的事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性。也就是说，隔离级别就是对对事务并发控制的等级。如果事务不考虑隔离性会引发以下问题：
      （1）脏读：
       指一个事务读取了另外一个事务未提交的数据。比如 A 向 B 购买商品，如果 B 的事务隔离级别为最低的 read uncommitted，那么当 A 执行了 update account set money=money+100 where name='B'；以后并没有提交数据的时候，B 进行了 select money from account where name='B'；查询账户的操作，由于 B 的事务隔离级别最低，所以导致了脏读，读取到了 A 没有提交的数据，当 A 执行了 rollback 回滚命令以后，B 再查询账户，就发现先前增加的 100 元消失了。为了避免脏读，我们可以将事务的隔离级别设置为：read committed。
       --
      （2）不可重复读：
       在一个事务内读取到了表中的某一行数据，多次读取结果不同。不可重复读和脏读的区别是：脏读是读取前一事务未提交的数据，不可重复读是重新读取了前一个事务已提交的数据。比如还是刚才的情景，当 B 将自己的事务隔离级别设置了 read committed 时，可以避免脏读，也就是别人没有提交的数据是读不到的。但是如果 A 将数据提交了，执行了 commit 命令后，B 在这个当前事务内再次查询账户的时候，就发现账户多了 100 元，这种情况看似是符合逻辑的，但是我们这里说到的不可重复读是指在这个当前事务内，不可以发生两次读取操作结果不一致的可能性，我们要保证在一个事务中，我们多次从数据库获取的数据应该是一致的，这样才能保证我们进行数据操作的可靠性。为了避免这个为题，我们可以将数据库的事务隔离级别设置为：repeatable read，这样就保证了在一个事务中，每次读取到数据都是一致的。
       --
      （3）虚读 ( 幻读 )
       在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。和不可重复读的区别是：不可重复读是读取到了别人对表中的某一条记录进行了修改，导致前后读取的数据不一致。  虚读是前后读取到表中的记录总数不一样，读取到了其它事务插入的数据。比如现在有 A 和 B 两个应用程序，他们并发访问了数据库中的某一张表，假设表中有 3 条记录，B 执行查询操作， 第一次查询表得到了 3 条记录。此时 A 对表进行了修改，增加了一条记录，当 B 再次查询表的时候，发现多了一条数据。这种情况就造成了 B 的虚读。但是虚读是不一定每次都发生的，这种情况是不确定的。为了避免虚读，我们可以将事务隔离级别设置为 serializable 如果设置成了这种级别，那么数据库就变成了单线程访问的数据库，导致性能降低很多。
       幻读，也可称为写倾斜，可以视为一种广义的更新丢失问题。即如果两个事务读取相同的一组对象，然后更新其中一部分；不同事物可能更新不同对象，则可能发生写倾斜，如果更新一个对象，那就是脏写了。
       产生写倾斜的例子一般满足以下类型：
       1.首先输入一些匹配条件，即采用Select查询满足条件的行。
       2.根据查询的结果，应用层代码决定下一步操作（继续，或终止）
       3.如果应用程序决定继续持续，则会对数据库发起写入（Insert、Update或Delete）并提交事务。而这个写操作会改变第二步的前提条件。
       以上步骤可以有不同的顺序，但是都会有可能导致问题。运气比较好的一种情况是：步骤3中修改的记录恰好是步骤1中的select查询的行，此时使用select for update可以保证修改记录时是加锁的，再查询时就可以保证事务安全。
       从而避免写倾斜，但是其他例子并不是适合，比如检查的是不满足给定搜索条件的行（期望返回为空），而符合条件的行为空，也就无从加锁了。
       
  
       
四种隔离级别及其特点：
waiting code、waiting draw

读未提交  大多数数据库使用行级锁来防止脏写，当事务想修改某个对象需要先获得该对象的锁，然后一直持有锁直到事务结束。而读未提交会导致脏读。


读已提交  读已提交，两种实现，一种就是在读未提交的基础上，对对象除了加写锁，还加了读锁，别人来读也要等这个事务结束。
          另一种实现就是MVCC，对每个带更新数据，有旧值和持有事务锁的新值，事务提交前其他操作读旧值，事务提交后读新值。

可重复读  可重复读，其实是观测方对一个事务的体现，为了解决这个问题，一般使用快照级别隔离，每个事务都从一致性快照中读取，事务一开始看到的是最近提交的数据，事务提交后也只能看到之前时间的旧数据。实际是一种读倾斜。

串行化    三十年来，可以说数据库只有一种串行化算法，即两阶段加锁（two-phase locking）2PL。代价就是事务吞吐量和查询响应时间都会下降非常多。

对于MySQL的MVCC机制，查询操作select不会更新版本号，属于快照读。而操作数据库表中数据insert、update、delete则会更新版本号，是当前读。

参考文档：
https://www.cnblogs.com/jpfss/p/9151698.html


### 查询需要加事务吗？
一般情况下，select不用放进一个事务，因为查询不涉及修改，哪怕失败了，也不会说有什么回滚操作。
因为select不会对数据库的产生持久化的修改，没有必要在数据发生不一致的时候进行回滚。如果要防止数据的不一致情况，可以通过修改事务的隔离级别实现。  

https://www.zhihu.com/question/266467051

### 事务实际使用案例

