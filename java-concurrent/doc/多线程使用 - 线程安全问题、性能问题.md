## 1.线程安全定义
《Java Concurrency In Practice》的作者 Brian Goetz 对线程安全是这样理解的，当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行问题，也不需要进行额外的同步，而调用这个对象的行为都可以获得正确的结果，那这个对象便是线程安全的。

事实上，Brian Goetz 想表达的意思是，如果某个对象是线程安全的，那么对于使用者而言，在使用时就不需要考虑方法间的协调问题，比如不需要考虑不能同时写入或读写不能并行的问题，也不需要考虑任何额外的同步问题，比如不需要额外自己加 synchronized 锁，那么它才是线程安全的，可以看出对线程安全的定义还是非常苛刻的。  

实际上，如果你再仔细研究Brian Goetz的话，会发现其实某种程度上线程安全是和业务相关的，如果我只是对一个arraylist做只读操作，没有添加和扩容，那么多线程并发也是安全的。  

> 再引申到哲学一点的考虑，一个稳定无误的系统是必须依赖所有组件的稳定无误，还是说我们可以使用一些不稳定的组件来构成一个稳定的系统。
如果我们把这里的不稳定组件视为线程不安全的容器，那对上面这个问题的回答就对应着我们是否可以使用线程不安全的容器构建一个线程安全的系统。

如果当多个线程访问同一个可变的状态变量且没有同步时，程序就会出现错误，有三种方式可以修复这种错误：
* 不在线程之间共享该变量 ThreadLocal
* 把该变量设置为不可变类型 Final
* 在访问状态变量时使用同步 synchronized Lock


那么一般会有哪些线程不安全的问题呢？
1.运行结果错误；   常见的如：并发i++
2.发布和初始化导致线程安全问题；  常见的如:线程A中创建了线程B，线程A、B顺序执行，其实并不知道谁先执行。 
3.活跃性问题。     常见的如: 死锁、活锁、饥饿

waiting code 
常见的

总结需要注意线程安全的场景:
1.访问共享变量或资源  i++问题
2.依赖时序的操作   检查并执行，判断并更新这些类似事务的操作
3.不同数据之间存在绑定关系   比如IP、端口、http连接池等
4.对方没有声明自己是线程安全的  比如arraylist注释里就说了自己不是线程安全的，要外部同步

## 多线程性能问题
多线程会带来的性能问题：
* 调度开销
** 上下文切换
** 缓存失效 L1 L2 Cache。在何处执行会有数量级的差异。

* 协作开销
比如使用关键字去禁止指令重排，实际就相当于抛弃了CPU的性能优化。或者增加了总线锁的使用。


后面线程池中会谈到程序分为IO密集型程序和CPU密集型程序。  




## 使用设计模式提高多线程性能


参考文档：  
http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98