## 1.典中典 Java中有那几种锁
### 7种分类
需要说明的是这里指的是锁的分类，也即概念上的分类，一个锁可以同时满足多种分类。
先把锁分成7种分类：

1.偏向锁、轻量级锁、重量级锁     这三种锁特指synchronized锁的状态
2.可重入锁 非可重入锁           可重入指锁的对象是线程而非调用。当前线程已经持有这把锁，能在不释放的情况下，再次获取。如ReentrantLock，synchronized。
     主要防止再次进入导致的死锁，所以实际实现需要去记录一个获取计数器和一个所有者线程。  
3.共享锁 独占锁                 共享锁可以同时被多个线程获取，而独占锁只能被一个线程获取。读写锁。  
4.公平锁 非公平锁               公平锁的等待队列是先进先出、非公平允许插队。  
5.悲观锁 乐观锁                 悲观锁一定要拿锁才能进行修改，乐观锁都不是锁，自然也没有拿锁操作，只是基于CAS在不独占资源情况下完成资源修改。  
      有一种说法认为，悲观锁由于它的操作比较重量级，不能多个线程并行执行，而且还会有上下文切换等动作，所以悲观锁的性能不如乐观锁好，应该尽量避免用悲观锁，这种说法是不正确的。
      
      因为虽然悲观锁确实会让得不到锁的线程阻塞，但是这种开销是固定的。悲观锁的原始开销确实要高于乐观锁，但是特点是一劳永逸，就算一直拿不到锁，也不会对开销造成额外的影响。
   
      反观乐观锁虽然一开始的开销比悲观锁小，但是如果一直拿不到锁，或者并发量大，竞争激烈，导致不停重试，那么消耗的资源也会越来越多，甚至开销会超过悲观锁。 需要看具体使用场景。
   
      悲观锁适合用于并发写入多、临界区代码复杂、竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。
   
      乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是并发并不激烈的场景。在这些场景下，乐观锁不加锁的特点能让性能大幅提高。  
6.自旋锁 非自旋锁               自旋锁拿不到锁是会利用循环不断去获取锁，非自旋锁一般是拿不到锁直接阻塞或者释放CPU资源。  
7.可中断锁 不可中断锁            synchronized 的锁就是不可中断锁，申请了锁，要么拿要么竞争。ReentrantLock 等基于AQS实现的锁就可以自己定义在中断后去做其他事。

waiting code 

### 实际使用的锁

* synchronized关键字代表的锁。
* AQS、Lock接口衍生的锁和工具类。
* voliatle、final、原子类、CAS操作等解决并发的工具类或关键字，并不是锁。


如果可以：
1.最好既不使用 Lock 也不使用 synchronized，而是优先使用 JUC 包中其他的成熟工具，因为它们通常会帮我们自动处理所有的加锁和解锁操作；
2.如果必须使用锁，则优先使用 synchronized，因为它可以减少代码编写的数量以及降低出错的概率，因为一旦使用 Lock，就必须在 finally 中写上 unlock，不然代码可能会出很大的问题，而使用 synchronized 就不必考虑这些问题，因为它会自动解锁。
3.如果 synchronized 不能满足我们的需求，需要使用一些Lock特性(有限等待、可中断、有返回值、公平锁、读写锁)时，就得考虑使用 Lock。