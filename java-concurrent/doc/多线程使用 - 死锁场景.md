## 1.死锁概念

死锁在很多地方都会存在，操作系统的死锁、数据库的死锁、java程序的死锁。他们底层逻辑都是一样的，也即都满足以下4个条件。
* 第 1 个叫互斥条件，它的意思是每个资源每次只能被一个线程（或进程，下同）使用，为什么资源不能同时被多个线程或进程使用呢？这是因为如果每个人都可以拿到想要的资源，那就不需要等待，所以是不可能发生死锁的。
* 第 2 个是请求与保持条件，它是指当一个线程因请求资源而阻塞时，则需对已获得的资源保持不放。如果在请求资源时阻塞了，并且会自动释放手中资源（例如锁）的话，那别人自然就能拿到我刚才释放的资源，也就不会形成死锁。
* 第 3 个是不剥夺条件，它是指线程已获得的资源，在未使用完之前，不会被强行剥夺。比如我们在上一课时中介绍的数据库的例子，它就有可能去强行剥夺某一个事务所持有的资源，这样就不会发生死锁了。所以要想发生死锁，必须满足不剥夺条件，也就是说当现在的线程获得了某一个资源后，别人就不能来剥夺这个资源，这才有可能形成死锁。
* 第 4 个是循环等待条件，只有若干线程之间形成一种头尾相接的循环等待资源关系时，才有可能形成死锁，比如在两个线程之间，这种“循环等待”就意味着它们互相持有对方所需的资源、互相等待；而在三个或更多线程中，则需要形成环路，例如依次请求下一个线程已持有的资源等。

但是死锁的影响在不同系统中是不一样的，影响的大小一部分取决于当前这个系统或者环境对死锁的处理能力。
比如数据库系统软件的设计中，考虑了检测死锁和从死锁中恢复的情况，因为执行一个事务可能要获取多把锁，并且要一直持有这些锁直到事务执行完成。  
而这种情况下如果一旦发生死锁，两个事务就会永远等待下去，所以数据库出现死锁的情况是更为常见的。   当出现死锁时，数据库事务程序会根据策略放弃某一事务，从而使其他事务正常进行。  

而JVM并没有这个死锁检测机制，如果JVM中出现了死锁， JVM并不会自动处理，于是就会一直死锁。  



## 2.Java中的死锁



## 3.死锁分析
死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。如果没有外力的作用，那么死锁涉及的各个线程都将永久处于循环等待状态，导致业务无法预期运行，所以我们的代码要避免死锁的情况。

理论上进入死锁的程序在无外力干预是会一直死锁的。
死锁代码演示
```
//线程Lock1代码示意

    while(true){

        synchronized("obj1"){

            Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2

            synchronized("obj2"){

                System.out.println("Lock1 lock obj2");

            }

        }

    }

    //线程Lock2代码示意

    while(true){

        synchronized("obj2"){

            Thread.sleep(3000); //获取obj2后先等一会儿，让Lock1有足够的时间锁住obj1

            synchronized("obj1"){

                System.out.println("Lock2 lock obj1");

            }

        }

    }
```
上面这个例子出现死锁的原因是两个不同线程获取锁的顺序是相反的，如果我们实际不关心获取锁的顺序，那么直接规定或者由外部组件调度获取锁的顺序即可解决。  
![](https://cdn.jsdelivr.net/gh/flowscolors/resources-backup@main/img_bed/jvm-死锁截图.JPG)

## 4.遇到死锁怎么解决
线上遇到死锁，首先结果已经发生，必须尽快恢复，所以重启是必须的。但是应该保存JVM、日志等案发现场信息。然后立刻重启，依赖信息排查死锁、修改代码、重新发布。               

我们有哪些常见的对于死锁的修复策略呢？下面将会介绍三种主要的修复策略，分别是：

* 避免策略

避免策略最主要的思路就是，优化代码逻辑，从根本上消除发生死锁的可能性。通常而言，发生死锁的一个主要原因是顺序相反的去获取不同的锁。所以只要按照一定顺序去获取锁即可。

* 检测与恢复策略

这是死锁已经发生的策略，即先允许系统发生死锁，然后再解除。系统可以每次调用锁时都记录下调用信息，一旦形成死锁，则执行死锁恢复机制，比如：  
1.线程终止，直接把终止已经死锁的线程。  
2.资源抢占，让一个线程回退几步，释放资源给另一个线程。

* 鸵鸟策略

直接不管，大部分内部的系统，那么在并发量极低的情况下，它可能几年都不会发生死锁。出现就重启解决。 
