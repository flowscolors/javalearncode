## 线程模型 OS、Java级别
书接上文，计算机内存模型是一种解决多线程场景下的一个主存操作规范，既然是规范，那么不同的编程语言都可以遵循这种操作规范，在多线程场景下访问主存保证原子性、可见性、有序性。
Java内存模型(Java Memory Model，JMM)即是Java语言对这个操作规范的遵循，JMM规定了所有的变量都存储在主存（Heap）中，每个线程都有自己的工作区（Stack），线程将使用到的变量从主存中复制一份到自己的工作区，线程对变量的所有操作(读取、赋值等)都必须在工作区，不同的线程也无法直接访问对方工作区，线程之间的消息传递都需要通过主存来完成。可以把这里主存类比成计算机内存模型中的主存，工作区类比成计算机内存模型中的高速缓存。

而我们知道JMM其实是工作主存中的，Java内存模型中的工作区也是主存中的一部分，所以可以这样说Java内存模型解决的是内存一致性问题(主存和主存)而计算机内存模型解决的是缓存一致性问题(CPU高速缓存和主存)，这两个模型类似，但是作用域不一样，Java内存模型保证的是主存和主存之间的原子性、可见性、有序性，而计算机内存模型保证的是CPU高速缓存和主存之间的原子性、可见性、有序性。
因为CPU只能解决缓存的问题，不能解决内存的问题，于是JMM Java内存模型，实际上是对Java多线程的线程一致性问题的解决，可以说是必然之路。

### JMM Java内存模型
Java线程的所有操作都是在工作区进行的，那么工作区和主存之间的变量交互如下图。
![](https://cdn.jsdelivr.net/gh/flowscolors/resources-backup@main/img_bed/Java内存模型交互图.JPG)
Java通过几种原子操作完成工作区内存和主存的交互

lock：作用于主存，把变量标识为线程独占状态。
unlock：作用于主存，解除变量的独占状态。
read：作用于主存，把一个变量的值通过主存传输到线程的工作区内存。
load：作用于工作区内存，把read操作传过来的变量值储存到工作区内存的变量副本中。
use：作用于工作内存，把工作区内存的变量副本传给执行引擎。
assign：作用于工作区内存，把从执行引擎传过来的值赋值给工作区内存的变量副本。
store：作用于工作区内存，把工作区内存的变量副本传给主存。
write：作用于主存，把store操作传过来的值赋值给主存变量。


这8个操作每个操作都是原子性的，但是几个操作连着一起就不是原子性了！

> Java为什么要做JMM，而不是L1 cache这种模型？
> 答：Java 作为高级语言，屏蔽了 L1 缓存、L2 缓存、L3 缓存，也就是多层缓存的这些底层细节，用 JMM 定义了一套读写数据的规范。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。

通过该模型，每个线程只能直接接触工作内存，无法直接操作主内存，而工作内存中保存的是主内存的共享变量的副本，主内存与共享内存的通信由JMM控制。  
JMM 有以下规定：

（1）所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝；

（2）线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改；

（3） 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。



### OS线程模型



### 线程同步机制
多线程的意思就是多个线程同时工作，那么多线程之间如何协同合作，这也就是我们需要解决的线程通信、线程同步问题

线程通信：线程通信指线程之间以何种机制来交换消息，线程之间的通信机制有两种：共享内存和消息传递。共享内存即线程通过对共享变量的读写而达到隐式通信，消息传递即线程通过发送消息给对方显示的进行通信。
线程同步：线程同步指不同线程对同一个资源进行操作时候线程应该以什么顺序去操作，线程同步依赖于线程通信，以共享内存方式进行线程通信的线程同步是显式的，以消息传递方式进行线程通信的线程同步是隐式的。

## Java程序与unsafe方法

Java对于操作系统底层接口的调用都是基于Unsafe(sun.misc.Unsafe)类实现，但是Java的跨平台性限制了Java不能和操作系统耦合，所以Java并没有在Unsafe类直接实现CAS的操作，而是通过JDI(Java Native Interface) 本地调用C/C++语言来实现CAS操作的。

![](https://cdn.jsdelivr.net/gh/flowscolors/resources-backup@main/img_bed/java_unsafe.jpg)


## happens-before 规则
Happens-before 关系是用来描述和可见性相关问题的：如果第一个操作 happens-before 第二个操作（也可以描述为，第一个操作和第二个操作之间满足 happens-before 关系），那么我们就说第一个操作对于第二个操作一定是可见的，也就是第二个操作在执行时就一定能保证看见第一个操作执行的结果。  
如果分别有操作 x 和操作 y，用 hb(x, y) 来表示 x happens-before y。  

（1）单线程规则： 在一个单独的线程中，按照程序代码的顺序，先执行的操作 happen-before 后执行的操作。也就是说，如果操作 x 和操作 y 是同一个线程内的两个操作，并且在代码里 x 先于 y 出现，那么有 hb(x, y)。  

（2）锁操作规则（synchronized 和 Lock 接口等）： 如果操作 A 是解锁，而操作 B 是对同一个锁的加锁，那么 hb(A, B) 。  

（3）volatile 变量规则： 对一个 volatile 变量的写操作 happen-before 后面对该变量的读操作。

（4）线程启动规则： Thread 对象的 start 方法 happen-before 此线程 run 方法中的每一个操作。

（5）线程 join 规则：假设线程 A 通过调用 threadB.start() 启动了一个新线程 B，然后调用 threadB.join() ，那么线程 A 将一直等待到线程 B 的 run 方法结束（不考虑中断等特殊情况），然后 join 方法才返回。  

（6）中断规则： 对线程 interrupt 方法的调用 happens-before 检测该线程的中断事件。

（7）并发工具类的规则：
> 线程安全的并发容器（如 HashTable）在 get 某个值时一定能看到在此之前发生的 put 等存入操作的结果。
>信号量（Semaphore）它会释放许可证，也会获取许可证。这里的释放许可证的操作 happens-before 获取许可证的操作.
>Future：Future 有一个 get 方法，可以用来获取任务的结果。那么，当 Future 的 get 方法得到结果的时候，一定可以看到之前任务中所有操作的结果，也就是说 Future 任务中的所有操作 happens-before Future 的 get 操作。
>线程池：要想利用线程池，就需要往里面提交任务（Runnable 或者 Callable），这里面也有一个 happens-before 关系的规则，那就是提交任务的操作 happens-before 任务的执行。






