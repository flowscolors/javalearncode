
Q:子类和父类的实例变量和方法有什么区别
A:访问变量看声明，访问方法看实际对象类型。这里假设子类、父类由相同的变量和方法。方法会被重写，而变量不会。Father c = new Chilren();这个例子中，
在以上父类引用指向子类对象情况下，访问变量看的是引用类型，所以c.age是父类的成员变量，而c.getAge()访问到的是子类Chilren的方法，所以在这个方法中用到的age变量是Chilren的变量。

Q:重载和覆盖区别，返回值类型不同，可以重载吗，为什么,底层如何实现的
A:重载是一个类中一个方法名的入参不同的多种方法，覆盖又叫重写是子类继承父类时覆盖掉父类的放啊。返回值不同可以重载。底层就是加载、链接（验证、准备、解析）、初始化的过程中实现的。

Q:String intern方法；
A:String.intern()是一个Native(本地)方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回字符串常量池中这个字符串的引用, 否则将当前String对象的引用地址（堆中）添加到字符串常量池中并返回。
String a = new String("hello"); String b = a.intern(); //常量池已有"hello"
String a = new String("hello") + "world";String b = a.intern(); //常量池已有"hello"、"world"，但无"helloworld",intern方法会存入。

Q:面向对象设计的5大法则?
A:SOLID法则。
S 单一功能，对象应该仅具有单一功能
O 开闭原则，对拓展开放，对修改关闭。
L 里氏替换原则，凡是父类使用的地方，子类都可以直接替换。程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”
I 接口隔离原则，不应强迫用户依赖他们不需要的方法。
D 依赖反转，高层模块不该依赖底层模块，二者都应该依赖抽象。抽象不应该依赖具体实现，具体实现应该依赖抽象。依赖注入是该原则的一种实现方式。

---
Q:hashmap原理，put和get，为什么是8转红黑树，红黑树节点添加过程，什么时候扩容，为什么是0.75，扩容步骤，为什么分高低位，1.7到1.8有什么优化，hash算法做了哪些优化，头插法有什么问题，为什么线程不安全
A:数组+链表+红黑树。put首先求索引值，h&(length-1)，位于操作比%快，长度少一位减少碰撞概率。
8转红黑树是为了防止查询的时间复杂度上升。扩容是当HashMap大小超过负载因子的数目，也即数组长度*负载因子，默认16*0.75，hashmap内容超过这个值就要扩容，因此此时如果数组没怎么存，那就是冲突的很多了。
扩容步骤：创建一倍大小的新数组，将原有数组的元素位移算到新数组中，把新数组置位hashmap的table属性。
头插法的问题在于扩容时，重hash，对于链表的每个元素，都通过indexFor重新找到桶的位置，如果链表所有元素的位置不变，则重写插入时链表顺序会颠倒，第一个索引的元素会被放到尾部，如果多线程会导致死循环。

Q:arraylist原理，为什么数组加transient，add和get时间复杂度，扩容原理，和linkedlist区别，原理，分别在什么场景下使用，为什么
A:动态数组。对象数组elementData被transient修饰，序列化时跳过。ArrayList add时间复杂度O(1)，理论默认尾插O(1)但是由于扩容导致并并没有那么快，而删除就很快了。指定位置插入则O(n)，查询时间复杂度O(1)。
扩容直接数组长度*1.5。没有像hashmap一样生成新的数组，而是使用Arrays.copyof()方法，在原数组的基础上进行复制，容量变为newCapacity的大小。
LinkedList区别就是LinkedList基于链表,基于插入顺序的有序。一般认为ArrayList插入慢，查询快。LinkedList查询慢，插入快。分别使用写少读多和写多读少的场景。
LinkedList 头插O(1)、指定位置插入O(n)、尾插O(n)、查询O(n)

Q:HashMap扩容时机（容量初始化为1000和10000是否触发扩容）、机制、1.7与1.8的差异
A:扩容机制在hasnmap存的键值对size超过数组长度*负载因子时触发resize()方法，容量初始化时不会触发扩容，因为懒加载，是在第一次put时候生成数组的。1.7、1.8主要在于头插变尾插解决并发插入导致的死循环问题。

Q:ConcurrentHashMap1.7、1.8的优化与差异，size方法实现差异
A:分段锁与节点锁。思想不变，1.8锁每个桶。

Q:为什么使用红黑树，不使用普通的二叉树。
A:为了排序，查找时候就不用遍历全部了。

---
Q:各种地方使用hashmap的区别？
HashMap。Java集合类，数组+链表+红黑树，默认长度8，负载因子0.75。哈希函数： hashcode()  冲突解决方案： 链地址法。 扩容倍乘。并发不安全。 
Redis hash。Redis基础数据结构。默认基于ZipList实现，数组+链表，初始化长度为4，loader_factor：哈希表中键值对数量 / 哈希表长度。大于5扩，小于0.1🔒。扩容时渐进式rehash，可以自己缩容。
Golang hashmap，数组+链表。buckets默认长度8，每个桶里面能存8个key、value值，负载因子6.5，以空间换时间.增量扩容、等量扩容、渐进式扩容。冲突解决方法，链地址法。并发不安全



