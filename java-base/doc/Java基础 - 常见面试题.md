
Q:面向对象语言特点？
A:面向过程的程序包含了数据定义和函数调用。而面向对象，因为对象描述了问题空间，而非计算机式的程序的概念。所以其实是把程序和问题用一种语言描述。

Q:Java 4种访问修饰符的区别？
A:Java提供三个显示关键字来设置访问控制，即public、private、ptotected，以及默认的Default。

Q:讲一讲多态与泛型？
A:多态是一种基于继承的机制，一个父类和若干子类的使用时，编译器何时调用子类的方法。其实际对应的是语言的“动态绑定”功能，在Java里语言自己实现该功能。  
多态的例子：方法 doSomething(Shape shape) ,则所有Shape的子类都可以使用该方法，用来执行各自的方法。这种将子类视为基类的过程称为“向上转型”。类似的功能如果不用子类基类做，那就是switch来做了。

泛型是一种参数化类型机制，一个被参数化的类型是一个特殊的类，可以让编译器自动适配特定的类型。在Java5支持。可以使用尖括号中间加类名来定义泛型。  
ArrayList<Shape> shapes = new ArrayList<>();`

Q:static关键字  
A:一般来说，我们会使用new关键字创建对象，并为其分配内存，使其方法可以被调用。然而两种场景下可能会有些不合时宜。
一是，只需要使用某个类的某个特定字段，而并不关心创建多少对象，甚至不要创建对象。
二是，只需要使用某个类的某个方法，而和具体的对象无关，甚至没有创建对象。
因此static可以用来修饰类的字段或方法，被static修饰的字段或方法会在内存中放一个共享区域。
注意调用static并不依赖是否提前创建对象，因此我们不能在没有具体对象的情况下，使用static去调用非static方法。

Q:final关键字  
A:final关键字代表常量，一个永远不会被改变的编译时常量，可以在运行时初始化，但不会被修改。对于值肯定是不变的，但是对象拿的是引用，所以这个对象用于是这个对象，但是里面的内容可能会变。  
final不会被修改的特点，可以用在并发编程中。final不会被修改的特点，可以防止继承类通过重写来改写基类方法。
fianl可以提高效率，在Java早期实现中，对于final方法，编译器会把对该方法的调用转换为内联调用，不执行入栈出栈，而是直接复制方法体中实际代码。这在曾经的代码中是出现过的，只是现在不鼓励，而是希望由编译器、JVM进行效率优化。

Q:子类和父类的实例变量和方法有什么区别
A:访问变量看声明，访问方法看实际对象类型。这里假设子类、父类由相同的变量和方法。方法会被重写，而变量不会。Father c = new Chilren();这个例子中，
在以上父类引用指向子类对象情况下，访问变量看的是引用类型，所以c.age是父类的成员变量，而c.getAge()访问到的是子类Chilren的方法，所以在这个方法中用到的age变量是Chilren的变量。

Q:重载和覆盖区别，返回值类型不同，可以重载吗，为什么,底层如何实现的
A:重载是一个类中一个方法名的入参不同的多种方法，覆盖又叫重写是子类继承父类时覆盖掉父类的放啊。返回值不同可以重载。底层就是加载、链接（验证、准备、解析）、初始化的过程中实现的。

Q:String intern方法；
A:String.intern()是一个Native(本地)方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回字符串常量池中这个字符串的引用, 否则将当前String对象的引用地址（堆中）添加到字符串常量池中并返回。
String a = new String("hello"); String b = a.intern(); //常量池已有"hello"
String a = new String("hello") + "world";String b = a.intern(); //常量池已有"hello"、"world"，但无"helloworld",intern方法会存入。

Q:面向对象设计的5大法则?
A:SOLID法则。
S 单一功能，对象应该仅具有单一功能
O 开闭原则，对拓展开放，对修改关闭。
L 里氏替换原则，凡是父类使用的地方，子类都可以直接替换。程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”
I 接口隔离原则，不应强迫用户依赖他们不需要的方法。
D 依赖反转，高层模块不该依赖底层模块，二者都应该依赖抽象。抽象不应该依赖具体实现，具体实现应该依赖抽象。依赖注入是该原则的一种实现方式。

---
Q:hashmap原理，put和get，为什么是8转红黑树，红黑树节点添加过程，什么时候扩容，为什么是0.75，扩容步骤，为什么分高低位，1.7到1.8有什么优化，hash算法做了哪些优化，头插法有什么问题，为什么线程不安全
A:数组+链表+红黑树。put首先求索引值，h&(length-1)，位于操作比%快，长度少一位减少碰撞概率。
8转红黑树是为了防止查询的时间复杂度上升。扩容是当HashMap大小超过负载因子的数目，也即数组长度*负载因子，默认16*0.75，hashmap内容超过这个值就要扩容，因此此时如果数组没怎么存，那就是冲突的很多了。
扩容步骤：创建一倍大小的新数组，将原有数组的元素位移算到新数组中，把新数组置位hashmap的table属性。
头插法的问题在于扩容时，重hash，对于链表的每个元素，都通过indexFor重新找到桶的位置，如果链表所有元素的位置不变，则重写插入时链表顺序会颠倒，第一个索引的元素会被放到尾部，如果多线程会导致死循环。

Q:arraylist原理，为什么数组加transient，add和get时间复杂度，扩容原理，和linkedlist区别，原理，分别在什么场景下使用，为什么
A:动态数组。对象数组elementData被transient修饰，序列化时跳过。ArrayList add时间复杂度O(1)，理论默认尾插O(1)但是由于扩容导致并并没有那么快，而删除就很快了。指定位置插入则O(n)，查询时间复杂度O(1)。
扩容直接数组长度*1.5。没有像hashmap一样生成新的数组，而是使用Arrays.copyof()方法，在原数组的基础上进行复制，容量变为newCapacity的大小。
LinkedList区别就是LinkedList基于链表,基于插入顺序的有序。一般认为ArrayList插入慢，查询快。LinkedList查询慢，插入快。分别使用写少读多和写多读少的场景。
LinkedList 头插O(1)、指定位置插入O(n)、尾插O(n)、查询O(n)

Q:HashMap扩容时机（容量初始化为1000和10000是否触发扩容）、机制、1.7与1.8的差异
A:扩容机制在hasnmap存的键值对size超过数组长度*负载因子时触发resize()方法，容量初始化时不会触发扩容，因为懒加载，是在第一次put时候生成数组的。1.7、1.8主要在于头插变尾插解决并发插入导致的死循环问题。

Q:ConcurrentHashMap1.7、1.8的优化与差异，size方法实现差异
A:分段锁与节点锁。思想不变，1.8锁每个桶。

Q:为什么使用红黑树，不使用普通的二叉树。
A:为了排序，查找时候就不用遍历全部了。

---
Q:各种地方使用hashmap的区别？
HashMap。Java集合类，数组+链表+红黑树，默认长度8，负载因子0.75。哈希函数： hashcode()  冲突解决方案： 链地址法。 扩容倍乘。并发不安全。 
Redis hash。Redis基础数据结构。默认基于ZipList实现，数组+链表，初始化长度为4，loader_factor：哈希表中键值对数量 / 哈希表长度。大于5扩，小于0.1🔒。扩容时渐进式rehash，可以自己缩容。
Golang hashmap，数组+链表。buckets默认长度8，每个桶里面能存8个key、value值，负载因子6.5，以空间换时间.增量扩容、等量扩容、渐进式扩容。冲突解决方法，链地址法。并发不安全



