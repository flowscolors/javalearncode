
Java 为了实现"一次编译，处处运行"，会把Java程序编译成class字节码文件，运行时会由解释器逐条把class字节码解释执行。而C++等编译型语言，直接把代码编译成机器码执行。  

如果字节码都要由解释器解释执行，那性能会不行。所以为了优化性能，JVM在解释器之外引入了即时（Just In Time）编译器，当程序运行时，解释器首先运行，保证class字节码可以解除成机器码直接开始执行。
随着时间的推移，即时编译器可以把越来越多的代码直接编译优化成本地代码，来获得更高的执行效率。也即  

走解释器，java代码 -> class字节码 -> 解释执行
走即时编译器，java代码 -> class字节码 -> 机器码(部分热点代码被编译) -> class字节码解释执行，机器码直接执行

## 1. JVM中的编译器
JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。
Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。

### C1  Client Compiler
实际上Client Compiler是一种类型，C1是其中的一种实现。


### C2  Server Compiler
实际上Server Compiler是一种类型，C2是其中的一种实现，Graal也是一种实现。



## 2. 分层编译
在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。
Java 7开始引入了分层编译的概念，JDK8默认开启。它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：

解释执行。
执行不带profiling的C1代码。
执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。
执行带所有profiling的C1代码。
执行C2代码。
profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。

通常情况下，C2代码的执行效率要比C1代码的高出30%以上。