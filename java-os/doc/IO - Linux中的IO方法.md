
Linux IO模式下有同步、异步、阻塞、非阻塞四个指标。

![](https://cdn.jsdelivr.net/gh/flowscolors/resources-backup@main/img_bed/Linux IO模式.png)

一般将网络消息是否有返回结果作为同步或异步的区分标准：
同步：应用程序直接参与IO读写操作，并等待消息响应结果。
异步：所有IO读写上交给OS操作，不等待消息响应结果，程序只需要等待通知。

阻塞和菲阻塞是指IO阶段的IO读写操作是否是阻塞：
阻塞：往往需要等待缓冲区的数据准备好才区处理，否则一直等待。
非阻塞：当进程访问数据缓存区时，如果数据没有准备好则直接返回，不会等待，如果数据已经准备好，则也直接返回。

所以我们常说的select、poll、epoll都属于异步阻塞，只实现了异步，实际IO还是阻塞，所以叫他们IO多路复用。
IO多路复用的特点是通过一个机制，使用一个单独的线程同时等待多个文件描述符

首先在java逻辑层使用代码实现客户端轮询的逻辑，肯定是不如底层OS的逻辑调用。  
NIO使用了操作系统底层的轮询系统调用 select/epoll（windows:select linux:epoll） 

## select
假设有A、B、C、D、E五个连接同时连接服务器，Java程序将会遍历这五个连接，轮询每个连接，获取各自数据准备情况.
但是我们写的Java程序其本质在轮询每个Socket的时候也需要去调用系统函数，那么轮询一次调用一次，会造成不必要的上下文切换开销。

而Select会将5个请求从用户态复制一份到内核态，在内核态空间直接判断每个请求是否准备好了数据，完全避免频繁上下文切换。
如果select没有查询到到有数据的请求，那么将会一直阻塞（是的，select是一个阻塞函数）。
如果有一个或者多个请求已经准备好数据了，那么select将会先将有数据的文件描述符置位，然后select返回。返回后通过遍历查看哪个请求有数据。

select的缺点：

1.底层存储依赖bitmap，处理的请求是有上限的，为1024。

2.文件描述符是会置位的，所以如果当被置位的文件描述符需要重新使用时，是需要重新赋空值的。

3.fd（文件描述符）从用户态拷贝到内核态仍然有一笔开销。

4.select返回后还要再次遍历，来获知是哪一个请求有数据。

## poll
poll的工作原理和select很像，先来看一段poll内部使用的一个结构体。
```text
struct pollfd{
    int fd;
    short events;
    short revents;
}
```
poll同样会将所有的请求拷贝到内核态，和select一样，poll同样是一个阻塞函数，当一个或多个请求有数据的时候，也同样会进行置位，
但是它置位的是结构体pollfd中的events或者revents置位，而不是对fd本身进行置位，所以在下一次使用的时候不需要再进行重新赋空值的操作。
poll内部存储不依赖bitmap，而是使用pollfd数组的这样一个数据结构，数组的大小肯定是大于1024的。解决了select 1、2两点的缺点。

## epoll
epoll是最新的一种多路IO复用的函数。这里只说说它的特点。

epoll和上述两个函数最大的不同是，它的fd是共享在用户态和内核态之间的，所以可以不必进行从用户态到内核态的一个拷贝，这样可以节约系统资源；
另外，在select和poll中，如果某个请求的数据已经准备好，它们会将所有的请求都返回，供程序去遍历查看哪个请求存在数据，但是epoll只会返回存在数据的请求，这是因为epoll在发现某个请求存在数据时，首先会进行一个重排操作，将所有有数据的fd放到最前面的位置，然后返回（返回值为存在数据请求的个数N），那么我们的上层程序就可以不必将所有请求都轮询，而是直接遍历epoll返回的前N个请求，这些请求都是有数据的请求。
也即无内核copy、返回后无需遍历解决了select的3、4两点的缺点。

