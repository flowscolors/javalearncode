
## 代码
代码在第一位，拿到性能优化需求时，首先应该分析代码，debug找到相应瓶颈。而非言必称缓存、异步、JVM。  
有很多性能问题是代码写的不合理，如for循环次数过多，很多无谓的条件判断、重复逻辑过多。下面给一个例子：
需要调用外部的一个接口拿到所有chart包信息，然后拿到所有的详细信息，最初的逻辑是是先调一个，再for循环调所有接口。
后面这个步骤在for循环做，当网络延迟大的时候就会耗时立马延长。后续改造成并发调用，forkjoin调用。  

## 数据库
数据库调优，大部分时候是影响最大的，可以将一个接口的时间从10s，到1s，到200ms。

### SQL调优
最常用、最应该掌握，也是最复杂的一种（所以DBA属于战略型武器）。以MYSQL为例，一般手段有各种SQL命令查占用CPU、内存高的SQL、慢查询日志、  
explain、profile工具来进行测试

### 数据库配置调优
一般这种大公司都有专业团队去做，修改/etc/my.cnf配置，基本的如隔离等级、innodb_buffer_pool_size 小公司的时候自己装MYSQL需要尤其注意。

### 连接池的调优
这部分数据库有自己的连接池配置、应用有自己的连接池配置，两边都要关注。涉及到吞吐量和返回速率的取舍。  

### 架构层面的调优
这一类就包括了读写分离、多从库负载均衡、水平和垂直分库分表等。这步骤涉及的改造较大，所以调优没有SQL调优频繁。一般需要DBA来参与。


## 缓存、NOSQL
本地缓存(HashMap、ConcurrentHashMap、Ehcache、Guava Cache等)，分布式缓存（Redis/Tair/Memcache等）。

### 一般使用场景:
1)  短时间内重复查询多次且数据更新不频繁。这时候可以选择先从缓存查询，查不到再从数据库加载并设置到缓存中，一般这种场景使用单机缓存即可。

2） 高并发查询热点数据，后端数据库不堪重负，可以用缓存来扛，这种一般使用Redis。  
当我们发现SQL已经无法优化时，比如一个SQL需要500ms，但是这个SQL在大并发访问时，会导致MYSQL数据库的连接数增多，时间片上下切换导致单个SQL时间延长。那只能上缓存了。  
  
3） 高并发对单个数据进行操作。这里其实是要保证数据的准确性的。  
在一个网关统计接口调用的场景时，比如每分钟只能调用100次，则每次请求来，filter都要去更新Redis的值，当减到0，则不允许调用。


### 设计关键点
* 什么时候更新缓存？如何保障更新的可靠性和实时性?
更新缓存的策略，需要具体策略具体分析。常用的双保险机制：消费kafka消息实时更新 + 5分钟过期后重新从DB load。

* 缓存是否会满，缓存满了怎么办？
对于一个缓存服务，理论上来说，随着缓存数据的日益增多，在容量有限的情况下，缓存肯定有一天会满的。如何应对？   
① 给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU。 
② 针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。 
③ 给一些没有必要长期保存的key，尽量设置过期时间。

* 缓存是否允许丢失？丢失了怎么办？
根据业务场景判断，是否允许丢失。如果不允许，就需要带持久化功能的缓存服务来支持，比如Redis。并且考虑业务对丢失场景的容忍度，需要考虑RDB、AOF模式。

* 缓存击穿
缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。  
业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。  
还是先继续Redis的返回，不让流量去到数据库。


## 异步、消息队列
一般当我们可以对请求做一些附属工作，并且不需要及时返回时，可以使用异步。


### 一般使用场景
一种做法，是额外开辟线程，这里可以采用额外开辟一个线程或者使用线程池的做法，在IO线程（处理请求响应）之外的线程来处理相应的任务，在IO线程中让response先返回。

如果异步线程处理的任务设计的数据量非常巨大，那么可以引入阻塞队列BlockingQueue作进一步的优化。具体做法是让一批异步线程不断地往阻塞队列里扔数据，然后额外起一个处理线程，循环批量从队列里拿预设大小的一批数据，来进行批处理（比如发一个批量的远程服务请求），这样进一步提高了性能。

另一种做法，是使用消息队列（MQ）中间件服务，MQ天生就是异步的。一些额外的任务，可能不需要我这个系统来处理，但是需要其他系统来处理。这个时候可以先把它封装成一个消息，扔到消息队列里面，通过消息中间件的可靠性保证把消息投递到关心它的系统，然后让这个系统来做相应的处理。

## JVM
首先要完成对JVM的监控，各类监控系统，简单的exporter即可实现。或者你启动时候配了相关gclog的参数。

### 一般的情况与排查：
1) 高峰期CPU使用过高、Load值过大。可能是young gc导致的，即gc线程一直要去做操作，占用了CPU。 
2) 接口返回过慢，连接超时。可能是full gc时间过长，甚至是old gen满了，一直在进行full gc。则CPU一直在进行GC，并且一直是STOP THE WORLD。

一般影响有内存溢出（如大批量查询导致）、内存溢出（hashmap没有remove导致）。一般需要使用mat、jamp进行分析。


## 并发与多线程

离线任务、异步任务、大数据任务、耗时较长任务的运行**，适当地利用，可达到加速的效果。

注意：线上对响应时间要求较高的场合，尽量少用多线程，尤其是服务线程需要等待任务线程的场合（很多重大事故就是和这个息息相关），如果一定要用，可以对服务线程设置一个最大等待时间。

如果单机的处理能力可以满足实际业务的需求，那么尽可能地使用单机多线程的处理方式，减少复杂性；反之，则需要使用多机多线程的方式。



## 分布式
分布式某种程度上可以看成一种多机多线程。  



参考文档：  
https://tech.meituan.com/2016/12/02/performance-tunning.html