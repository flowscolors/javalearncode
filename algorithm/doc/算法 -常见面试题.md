
Q:给定一个长度为N的整形数组arr，其中有N个互不相等的自然数1-N，请实现arr的排序，但是不要把下标0∼N−1位置上的数通过直接赋值的方式替换成1∼N


Q:判断一个树是否是平衡二叉树
A:平衡二叉树属于和层有关的问题，至多只有一层没有被填满，可以用双队列记录每层的值，遍历完一层则进入下一层。



Q:10个多线程保证 i从0加到10 
A:多线程相加，预计结果为100，实际可以把数值放的更大，效果会更明显。MultiThreadAdd()。
for循环起10个线程，每个线程去操作被voliatle修饰的int变量，最后结果是加到450。
但问题在于主线程输出的sout时，其他线程的任务是否执行完。这时候就需要CountDownLatch来实现,每个线程完成自己任务后 countDownLatch.countDown()。


Q:反转链表
A:单纯的对链表进行操作，并且只是把之前的next指针指向的位置指向前一个，本身的位置不同，故每次位移需要之前pre、cur、next三个节点位置，最后遍历链表并进行操作即可。
初始时，pre=null，cur=head,next=head.next，遍历条件是while(head!=null),最后返回的是pre，因为跳出循环时head已经是null了。
每次循环里面，把三个值放到下一次的位置，然后把原head的next值指向pre.

Q:上台阶（n=80)
A:首先如果返回值为int,则输入n=46时就会超过大小了。n=45时，result = 1836311903。
那么解法1.递归，利用f(n) = f(n-1) + f(n-2)，直接递归。 解法2，递归都可以转化成迭代，所以从之前的结果一个个加起来，减少函数栈深度。
解法3.动态规划，基于2的基础上，把之前算过的数据用数组存起来，减少重复计算。

Q:求一个float数的立方根，牛顿迭代法
A:解法1.基于二分法，这里先只考虑正整数，范围每次在0到float，每次取中间的数，判断三次方与输入的大小，确定左右调整。不过问题在于二分可能奇数第一次就分到小数点后面，后面也都带小数，比如预期是17.实际算的是16.9999999.
解法2.牛顿迭代法，需要数学公式推导。

Q:树的非递归先序遍历
A:首先写框架的测试代码，需要构造一棵树。然后是执行函数，首先得直到结果应该是什么，再进行计算。
递归：定义递归函数dfs(TreeNode treeNode)，
迭代：

Q:对于一个字符串，计算其中最长回文子串的长度。LeetCode-CN 5
A:最长回文子串。
1.暴力解法：把字符串切成所有的子字符串，判断是否是回文，如果是则判断并更新max长度。遍历需要O(n^2)，判断需要O(n)。
2.动态规划：

Q:给定一个二叉树，请计算节点值之和最大的路径的节点值之和是多少，这个路径的开始节点和结束节点可以是二叉树中的任意节点。 LeetCode-CN 124

